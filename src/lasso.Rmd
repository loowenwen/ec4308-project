---
title: "lasso"
author: "Abigail"
date: "2025-10-28"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r load libraries}
library(glmnet)
library(hdm)
library(tidyverse)
library(doParallel) #for parallel core running
library(foreach)
library(irlba)
library(HDeconometrics)
```

```{r reading in environment variables}
y_t
X_t


```


## LASSO


```{r lasso plug-in non-F}
horizons <- c(1,3,6,12)
save_path <- "rlasso_results_100.rds"

# Load previous progress if available
if (file.exists(save_path)) {
  results <- readRDS(save_path)
  cat("Loaded existing results from", save_path, "\n")
} else {
  results <- list()
  cat("Starting new results list\n")
}


# === Detect and register cores ===
n_cores <- parallel::detectCores() - 3  # leave a couple free
cl <- makeCluster(n_cores)
registerDoParallel(cl)

cat("Running plug-in LASSO using", n_cores, "cores\n")



# === MAIN LOOP ===
all_Z_list <- readRDS("all_Z_matrices.rds")
Z_list <- all_Z_list
y_t = y_t 
nprev <- 100

# Reorder Z_list by increasing number of columns (excluding sasdate)
Z_order <- names(sort(sapply(Z_list, function(z) ncol(z))))
Z_list <- Z_list[Z_order]

# Filter to keep only Zs without "F" in their names
Z_list <- Z_list[!grepl("F", names(Z_list))]

for (z_name in names(Z_list)) {
  Z_full <- Z_list[[z_name]]
  Z <- Z_full %>% select(-sasdate)
  cat("\n=============================\n")
  cat("Running for:", z_name, "\n")

  if (is.null(results[[z_name]])) results[[z_name]] <- list()

  # Tail y to match Z
  if (nrow(y_t) > nrow(Z)) {
    y_aligned <- tail(y_t, nrow(Z))
    cat("  Tailed y from", nrow(y_t), "to", nrow(y_aligned), "\n")
  } else {
    y_aligned <- y_t
  }

  cat("  First 3 Z dates:", paste(as.character(Z_full$sasdate[1:3]), collapse = ", "), "\n")
  cat("  First 3 y dates:", paste(as.character(y_aligned$sasdate[1:3]), collapse = ", "), "\n")

  # === Horizon loop ===
  for (h in horizons) {
    if (!is.null(results[[z_name]][[paste0("h", h)]])) {
      cat("  Skipping horizon", h, "(already done)\n")
      next
    }

    cat("  Horizon:", h, "\n")
    y_h <- dplyr::lead(y_aligned$CPI_t, h)
    valid_idx <- 1:(length(y_h) - h)

    # === Parallel rolling window ===
    preds <- foreach(i = seq_len(nprev), .combine = c, .packages = c("hdm")) %dopar% {
      train_start <- i
      train_end <- length(y_h[valid_idx]) - nprev + i - 1
      Z_train <- Z[train_start:train_end, ]
      y_train <- y_h[train_start:train_end]
      Z_test  <- Z[train_end + 1, , drop = FALSE]

      # plug-in lambda fit
      model <- rlasso(Z_train, y_train, post = TRUE)
      predict(model, newdata = Z_test)
    }

    # === Compute RMSE/MAE per horizon ===
    real <- tail(y_h[valid_idx], nprev)
    rmse <- sqrt(mean((real - preds)^2))
    mae  <- mean(abs(real - preds))

    results[[z_name]][[paste0("h", h)]] <- list(
      pred = preds,
      errors = c(rmse = rmse, mae = mae)
    )

    cat("    Horizon", h, "done. RMSE:", round(rmse, 4), "MAE:", round(mae, 4), "\n")
    saveRDS(results, save_path)
    cat("  Progress saved to", save_path, "\n")
  }

  cat("*** Finished all horizons for", z_name, "***\n\n")
}

stopCluster(cl)


# === Summary printout ===
cat("\nSummary of results:\n")
for (z_name in names(results)) {
  cat("Results for:", z_name, "\n")
  for (h in horizons) {
    if (!is.null(results[[z_name]][[paste0("h", h)]])) {
      error_vec <- results[[z_name]][[paste0("h", h)]]$errors
      cat("  Horizon", h, ": RMSE =", round(error_vec["rmse"], 4), 
          ", MAE =", round(error_vec["mae"], 4), "\n")
    } else {
      cat("  Horizon", h, ": not yet computed\n")
    }
  }
}


```



```{r comparison}

lasso_results <- readRDS("rlasso_results_100.rds")

# collect RMSEs for each horizon
mse_summary <- do.call(rbind, lapply(names(lasso_results), function(z_name) {
  res_list <- lasso_results[[z_name]]
  do.call(rbind, lapply(names(res_list), function(h) {
    rmse_val <- res_list[[h]]$rmse
    data.frame(
      Z_name = z_name,
      Horizon = h,
      RMSE = rmse_val,
      MSE = rmse_val^2
    )
  }))
})) %>%
  as.data.frame()

# ranked each horizon (1 is smallest MSE)
mse_ranked <- mse_summary %>%
  group_by(Horizon) %>%
  mutate(Rank = rank(MSE, ties.method = "first")) %>%
  arrange(Horizon, Rank) %>%
  ungroup()
```


```{r lasso plug in F matrices nprev=100, no X}
# --- Helper function: compute PCs and add lags ---
add_pca_factors <- function(X_train, X_test, n_pcs = 32, n_lags = 1) {
  # Train PCA basis on training X
  pcs_basis <- prcomp(scale(X_train), center = TRUE, scale. = TRUE, rank. = n_pcs)
  
  # Compute training PCs
  pcs_train <- predict(pcs_basis, newdata = scale(X_train, center = pcs_basis$center, scale = pcs_basis$scale))
  pcs_train_df <- as.data.frame(pcs_train)
  colnames(pcs_train_df) <- paste0("PC", 1:n_pcs)
  
  # Compute test PCs
  pcs_test <- predict(pcs_basis, newdata = scale(X_test, center = pcs_basis$center, scale = pcs_basis$scale))
  pcs_test_df <- as.data.frame(pcs_test)
  colnames(pcs_test_df) <- paste0("PC", 1:n_pcs)
  
  # Add lagged PCs to training data
  if (n_lags > 0) {
    for (lag_i in 1:n_lags) {
      lagged_pcs <- dplyr::lag(pcs_train_df, lag_i)
      colnames(lagged_pcs) <- paste0("PC", 1:n_pcs, "_lag", lag_i)
      pcs_train_df <- cbind(pcs_train_df, lagged_pcs)
      
      # For test obs, take last available lag values from training
      pcs_test_df[paste0("PC", 1:n_pcs, "_lag", lag_i)] <- tail(pcs_train_df, lag_i)[1, 1:n_pcs]
    }
  }
  
  list(train_pcs = pcs_train_df, test_pcs = pcs_test_df)
}

# --- Main rolling window loop ---
n_pcs <- 32
n_lags <- 4
save_path <- "rlasso_results_100.rds"

if (file.exists(save_path)) {
  results <- readRDS(save_path)
  cat("Loaded existing results from", save_path, "\n")
} else {
  results <- list()
}

all_Z_list <- readRDS("all_Z_matrices.rds")
Z_list <- all_Z_list[grepl("F", names(all_Z_list))]
Z_list <- Z_list[!grepl("MAF", names(Z_list))]

Z_order <- names(sort(sapply(Z_list, function(z) ncol(z))))
Z_list <- Z_list[Z_order]

# Predefined stationary matrix X_t (should match row count with y_t and Z)
X_t <- X_t

for (z_name in names(Z_list)) {
  Z <- Z_list[[z_name]]
  Z <- Z %>% select(-sasdate)
  cat("\n=============================\nRunning for:", z_name, "\n")
  
  if (is.null(results[[z_name]])) results[[z_name]] <- list()
  
  if (nrow(y_t) > nrow(Z)) {
    y_aligned <- tail(y_t, nrow(Z))
    X_aligned <- tail(X_t, nrow(Z))
  } else {
    y_aligned <- y_t
    X_aligned <- X_t
  }
  
  for (h in horizons) {
    hname <- paste0("h", h)
    if (!is.null(results[[z_name]][[hname]])) {
      cat("  Skipping horizon", h, "(already done)\n")
      next
    }
    
    cat("  Horizon:", h, "\n")
    y_h <- dplyr::lead(y_aligned$CPI_t, h)
    valid_idx <- 1:(length(y_h) - h)
    
    preds <- foreach(i = seq_len(nprev), .combine = c, .packages = c("hdm", "dplyr", "irlba")) %dopar% {
      train_start <- i
      train_end <- length(y_h[valid_idx]) - nprev + i - 1
      
      Z_train_raw <- Z[train_start:train_end, ]
      y_train <- y_h[train_start:train_end]
      Z_test_raw <- Z[train_end + 1, , drop = FALSE]
      
      X_train_raw <- X_aligned[train_start:train_end, ]
      X_test_raw <- X_aligned[train_end + 1, , drop = FALSE]
      
      # === Compute PCA factors from X_t and append to Z ===
      pcs_data <- add_pca_factors(X_train_raw, X_test_raw, n_pcs = n_pcs, n_lags = n_lags)
      Z_train <- cbind(Z_train_raw, pcs_data$train_pcs)
      Z_test <- cbind(Z_test_raw, pcs_data$test_pcs)
      
      model <- rlasso(Z_train, y_train, post = TRUE)
      predict(model, newdata = Z_test)
    }
    
    real <- tail(y_h[valid_idx], nprev)
    rmse <- sqrt(mean((real - preds)^2))
    mae <- mean(abs(real - preds))
    
    results[[z_name]][[hname]] <- list(pred = preds, errors = c(rmse = rmse, mae = mae))
    cat("    Horizon", h, "done. RMSE:", rmse, "MAE:", mae, "\n")
    saveRDS(results, save_path)
  }
  
  cat("*** Finished all horizons for", z_name, "***\n")
}

stopCluster(cl)

```
```{r lasso bic no factors}
alpha <- 1
IC <- "bic"
save_path <- "lasso_bic_results_100_icglm.rds"

# Load previous progress if available
if (file.exists(save_path)) {
  results <- readRDS(save_path)
  cat("Loaded existing results from", save_path, "\n")
} else {
  results <- list()
  cat("Starting new results list\n")
}


# ---- parallel setup ----
Z_list <- all_Z_list[
  order(sapply(all_Z_list, ncol))
]
Z_list <- Z_list[!grepl("F", names(Z_list))]

Z_list <- lapply(Z_list, function(df) {
  df %>% drop_na()
})

results <- list()

for (z_name in names(Z_list)) {
  
  Z_full <- Z_list[[z_name]]
  Z <- Z_full %>% select(-sasdate)
  y_vec <- tail(y_t$CPI_t, nrow(Z))
  
  cat("\n=============================\nRunning:", z_name, "\n")
  
  results[[z_name]] <- list()
  
  for (h in horizons) {
    
    cat("  Horizon:", h, "\n")
    
    y_target <- dplyr::lead(y_vec, h)[1:(nrow(Z) - h)]
    Z_trim   <- Z[1:(nrow(Z) - h), ]
    
    window_size <- nrow(Z_trim) - nprev
    
    # parallel version of rolling window
    pred_out <- foreach(i = seq_len(nprev), .combine = "c", .packages = c("hdm", "HDeconometrics")) %dopar% {
      
      train_start <- i
      train_end   <- i + window_size - 1
      
      Z_train <- as.matrix(Z_trim[train_start:train_end, ])
      y_train <- y_target[train_start:train_end]
      Z_test  <- as.matrix(Z_trim[train_end + 1, ])
      
      if (sd(y_train) == 0 || all(is.na(y_train))) {
        return(NA)
      }
      
      model <- ic.glmnet(
        x = Z_train,
        y = y_train,
        alpha = alpha,
        crit = IC
      )
      
      as.numeric(predict(model, Z_test))
    }
    
    true_y <- tail(y_target, nprev)
    
    results[[z_name]][[paste0("h", h)]] <- list(
      pred = pred_out,
      rmse = sqrt(mean((true_y - pred_out)^2, na.rm = TRUE)),
      mae  = mean(abs(true_y - pred_out), na.rm = TRUE)
    )
    
    cat("    Horizon", h, "done.\n")
    cat("    MSE:", round(results[[z_name]][[paste0("h", h)]]$rmse, 4),
        "| MAE:", round(results[[z_name]][[paste0("h", h)]]$mae, 4), "\n")
    saveRDS(results, save_path)
    cat("  Progress saved to", save_path, "\n")
  }
}

stopCluster(cl)  

# print summary
cat("\n=========== SUMMARY (LASSO via IC) ===========\n")
for (z_name in names(results)) {
  cat("Results for:", z_name, "\n")
  for (h in horizons) {
    err <- results[[z_name]][[paste0("h", h)]]
    cat("  h =", h,
        "| RMSE =", round(err$rmse, 4),
        "| MAE =", round(err$mae, 4), "\n")
  }
}

```


```{r lasso bic WITH factors}
alpha <- 1
IC <- "bic"
n_pcs <- 32
n_lags <- 4
save_path <- "lasso_bic_results_100_icglm.rds"

# --- Load previous progress if available ---
if (file.exists(save_path)) {
  results <- readRDS(save_path)
  cat("Loaded existing results from", save_path, "\n")
} else {
  results <- list()
  cat("Starting new results list\n")
}

# --- Load data ---
Z_list <- all_Z_list[
  order(sapply(all_Z_list, ncol))
]
Z_list <- Z_list[grepl("F", names(Z_list))]
Z_list <- Z_list[!grepl("MAF", names(Z_list))]

# Predefined stationary X_t for PCA
X_t <- X_t

# Drop any remaining NAs (alr checked that they are due to lagging)
Z_list <- lapply(Z_list, function(df) {
  df %>% drop_na()
})


# --- Main Loop ---
for (z_name in names(Z_list)) {
  
  Z_full <- Z_list[[z_name]]
  Z <- Z_full %>% select(-sasdate)
  y_vec <- tail(y_t$CPI_t, nrow(Z))
  X_aligned <- tail(X_t, nrow(Z))
  
  cat("\n=============================\nRunning:", z_name, "\n")
  results[[z_name]] <- list()
  
  for (h in horizons) {
    cat("  Horizon:", h, "\n")
    
    y_target <- dplyr::lead(y_vec, h)[1:(nrow(Z) - h)]
    Z_trim   <- Z[1:(nrow(Z) - h), ]
    X_trim   <- X_aligned[1:(nrow(X_aligned) - h), ]
    
    window_size <- nrow(Z_trim) - nprev
    
    pred_out <- foreach(i = seq_len(nprev), .combine = "c",
                        .packages = c("hdm", "HDeconometrics", "dplyr")) %dopar% {
                          
                          train_start <- i
                          train_end   <- i + window_size - 1
                          
                          # --- Split windows ---
                          Z_train_raw <- as.matrix(Z_trim[train_start:train_end, ])
                          Z_test_raw  <- as.matrix(Z_trim[train_end + 1, ])
                          X_train_raw <- as.matrix(X_trim[train_start:train_end, ])
                          X_test_raw  <- as.matrix(X_trim[train_end + 1, ])
                          y_train <- y_target[train_start:train_end]
                          
                          if (sd(y_train) == 0 || all(is.na(y_train))) {
                            return(NA)
                          }
                          
                          # --- Add PCA factors (same as old version) ---
                          pcs_data <- add_pca_factors(
                            X_train = X_train_raw,
                            X_test  = X_test_raw,
                            n_pcs   = n_pcs,
                            n_lags  = n_lags
                          )
                          
                          Z_train <- cbind(Z_train_raw, pcs_data$train_pcs)
                          Z_test  <- cbind(Z_test_raw, pcs_data$test_pcs)
                          
                          # drop rows with any NA in training set, align y_train accordingly
                          na_rows <- apply(Z_train, 1, function(x) any(is.na(x)))
                          Z_train <- Z_train[!na_rows, , drop = FALSE]
                          y_train <- y_train[!na_rows]
                          
                          # --- Run ic.glmnet with information criterion ---
                          model <- ic.glmnet(
                            x = Z_train,
                            y = y_train,
                            alpha = alpha,
                            crit = IC
                          )
                          
                          # --- Predict next obs ---
                          as.numeric(predict(model, newx = Z_test))
                        }
    
    # --- Store results ---
    true_y <- tail(y_target, nprev)
    results[[z_name]][[paste0("h", h)]] <- list(
      pred = pred_out,
      rmse = sqrt(mean((true_y - pred_out)^2, na.rm = TRUE)),
      mae  = mean(abs(true_y - pred_out), na.rm = TRUE)
    )
    
    cat("    Horizon", h, "done.\n")
    cat("    RMSE:", round(results[[z_name]][[paste0('h', h)]]$rmse, 4),
        "| MAE:", round(results[[z_name]][[paste0('h', h)]]$mae, 4), "\n")
    saveRDS(results, save_path)
    cat("  Progress saved to", save_path, "\n")
  }
}

stopCluster(cl)

# --- Print Summary ---
cat("\n=========== SUMMARY (ic.glmnet + PCA) ===========\n")
for (z_name in names(results)) {
  cat("Results for:", z_name, "\n")
  for (h in horizons) {
    err <- results[[z_name]][[paste0("h", h)]]
    cat("  h =", h,
        "| RMSE =", round(err$rmse, 4),
        "| MAE =", round(err$mae, 4), "\n")
  }
}
```

