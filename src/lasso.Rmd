---
title: "lasso"
author: "Abigail"
date: "2025-10-28"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r load libraries}
library(glmnet)
library(hdm)
library(tidyverse)
library(doParallel) #for parallel core running
library(foreach)
library(irlba)
library(HDeconometrics)
library(tidyr)
library(ggplot2)
```

```{r reading in environment variables}
y_t = readRDS("y_t.rds")
X_t = readRDS("X_t.rds")

```


## LASSO


```{r lasso plug-in non-F}
horizons <- c(1,3,6,12)
save_path <- "rlasso_results.rds"

# Load previous progress if available
if (file.exists(save_path)) {
  results <- readRDS(save_path)
  cat("Loaded existing results from", save_path, "\n")
} else {
  results <- list()
  cat("Starting new results list\n")
}


# === Detect and register cores ===
n_cores <- parallel::detectCores() - 3  # leave a couple free
cl <- makeCluster(n_cores)
registerDoParallel(cl)

cat("Running plug-in LASSO using", n_cores, "cores\n")



# === MAIN LOOP ===
all_Z_list <- readRDS("all_Z_matrices.rds")
Z_list <- all_Z_list
#y_t = y_t 
nprev <- 100

# Reorder Z_list by increasing number of columns (excluding sasdate)
Z_order <- names(sort(sapply(Z_list, function(z) ncol(z))))
Z_list <- Z_list[Z_order]

# Filter to keep only Zs without "F" in their names
Z_list <- Z_list[!grepl("F", names(Z_list))]

for (z_name in names(Z_list)) {
  Z_full <- Z_list[[z_name]]
  Z <- Z_full %>% select(-sasdate)
  cat("\n=============================\n")
  cat("Running for:", z_name, "\n")

  if (is.null(results[[z_name]])) results[[z_name]] <- list()

  # Tail y to match Z
  if (nrow(y_t) > nrow(Z)) {
    y_aligned <- tail(y_t, nrow(Z))
    cat("  Tailed y from", nrow(y_t), "to", nrow(y_aligned), "\n")
  } else {
    y_aligned <- y_t
  }

  cat("  First 3 Z dates:", paste(as.character(Z_full$sasdate[1:3]), collapse = ", "), "\n")
  cat("  First 3 y dates:", paste(as.character(y_aligned$sasdate[1:3]), collapse = ", "), "\n")

  # === Horizon loop ===
  for (h in horizons) {
    if (!is.null(results[[z_name]][[paste0("h", h)]])) {
      cat("  Skipping horizon", h, "(already done)\n")
      next
    }

    cat("  Horizon:", h, "\n")
    y_h <- dplyr::lead(y_aligned$CPI_t, h)
    valid_idx <- 1:(length(y_h) - h)

    # === Parallel rolling window ===
    preds <- foreach(i = seq_len(nprev), .combine = c, .packages = c("hdm")) %dopar% {
      train_start <- i
      train_end <- length(y_h[valid_idx]) - nprev + i - 1
      Z_train <- Z[train_start:train_end, ]
      y_train <- y_h[train_start:train_end]
      Z_test  <- Z[train_end + 1, , drop = FALSE]

      # plug-in lambda fit
      model <- rlasso(Z_train, y_train, post = TRUE)
      predict(model, newdata = Z_test)
    }

    # === Compute RMSE/MAE per horizon ===
    real <- tail(y_h[valid_idx], nprev)
    rmse <- sqrt(mean((real - preds)^2))
    mae  <- mean(abs(real - preds))

    results[[z_name]][[paste0("h", h)]] <- list(
      pred = preds,
      rmse = rmse, 
      mae = mae
    )

    cat("    Horizon", h, "done. RMSE:", round(rmse, 4), "MAE:", round(mae, 4), "\n")
    saveRDS(results, save_path)
    cat("  Progress saved to", save_path, "\n")
  }

  cat("*** Finished all horizons for", z_name, "***\n\n")
}

stopCluster(cl)


# === Summary printout ===
cat("\nSummary of results:\n")
for (z_name in names(results)) {
  cat("Results for:", z_name, "\n")
  for (h in horizons) {
    if (!is.null(results[[z_name]][[paste0("h", h)]])) {
      rmse <- results[[z_name]][[paste0("h", h)]]$rmse
      mae <- results[[z_name]][[paste0("h", h)]]$mae
      cat("  Horizon", h, ": RMSE =", round(rmse, 4), 
          ", MAE =", round(mae, 4), "\n")
    } else {
      cat("  Horizon", h, ": not yet computed\n")
    }
  }
}


```



```{r comparison}

lasso_results <- readRDS("rlasso_results_100.rds")

# collect RMSEs for each horizon
mse_summary <- do.call(rbind, lapply(names(lasso_results), function(z_name) {
  res_list <- lasso_results[[z_name]]
  do.call(rbind, lapply(names(res_list), function(h) {
    rmse_val <- res_list[[h]]$rmse
    data.frame(
      Z_name = z_name,
      Horizon = h,
      RMSE = rmse_val,
      MSE = rmse_val^2
    )
  }))
})) %>%
  as.data.frame()

# ranked each horizon (1 is smallest MSE)
mse_ranked <- mse_summary %>%
  group_by(Horizon) %>%
  mutate(Rank = rank(MSE, ties.method = "first")) %>%
  arrange(Horizon, Rank) %>%
  ungroup()
```


```{r lasso plug in F matrices nprev=100, add X for pcs}
# --- Helper function: compute PCs and add lags ---
add_pca_factors <- function(X_train, X_test, n_pcs = 32, n_lags = 1) {
  # Train PCA basis on training X
  pcs_basis <- prcomp(scale(X_train), center = TRUE, scale. = TRUE, rank. = n_pcs)
  
  # Compute training PCs
  pcs_train <- predict(pcs_basis, newdata = scale(X_train, center = pcs_basis$center, scale = pcs_basis$scale))
  pcs_train_df <- as.data.frame(pcs_train)
  colnames(pcs_train_df) <- paste0("PC", 1:n_pcs)
  
  # Compute test PCs
  pcs_test <- predict(pcs_basis, newdata = scale(X_test, center = pcs_basis$center, scale = pcs_basis$scale))
  pcs_test_df <- as.data.frame(pcs_test)
  colnames(pcs_test_df) <- paste0("PC", 1:n_pcs)
  
  # Add lagged PCs to training data
  if (n_lags > 0) {
    for (lag_i in 1:n_lags) {
      lagged_pcs <- dplyr::lag(pcs_train_df, lag_i)
      colnames(lagged_pcs) <- paste0("PC", 1:n_pcs, "_lag", lag_i)
      pcs_train_df <- cbind(pcs_train_df, lagged_pcs)
      
      # For test obs, take last available lag values from training
      pcs_test_df[paste0("PC", 1:n_pcs, "_lag", lag_i)] <- tail(pcs_train_df, lag_i)[1, 1:n_pcs]
    }
  }
  
  list(train_pcs = pcs_train_df, test_pcs = pcs_test_df)
}

# --- Main rolling window loop ---
n_pcs <- 32
n_lags <- 4
save_path <- "rlasso_results.rds"

if (file.exists(save_path)) {
  results <- readRDS(save_path)
  cat("Loaded existing results from", save_path, "\n")
} else {
  results <- list()
}

all_Z_list <- readRDS("all_Z_matrices.rds")
Z_list <- all_Z_list[grepl("F", names(all_Z_list))]
Z_list <- Z_list[!grepl("MAF", names(Z_list))]

Z_order <- names(sort(sapply(Z_list, function(z) ncol(z))))
Z_list <- Z_list[Z_order]

# Predefined stationary matrix X_t (should match row count with y_t and Z)
X_t <- X_t

for (z_name in names(Z_list)) {
  Z <- Z_list[[z_name]]
  Z <- Z %>% select(-sasdate)
  cat("\n=============================\nRunning for:", z_name, "\n")
  
  if (is.null(results[[z_name]])) results[[z_name]] <- list()
  
  if (nrow(y_t) > nrow(Z)) {
    y_aligned <- tail(y_t, nrow(Z))
    X_aligned <- tail(X_t, nrow(Z))
  } else {
    y_aligned <- y_t
    X_aligned <- X_t
  }
  
  for (h in horizons) {
    hname <- paste0("h", h)
    if (!is.null(results[[z_name]][[hname]])) {
      cat("  Skipping horizon", h, "(already done)\n")
      next
    }
    
    cat("  Horizon:", h, "\n")
    y_h <- dplyr::lead(y_aligned$CPI_t, h)
    valid_idx <- 1:(length(y_h) - h)
    
    preds <- foreach(i = seq_len(nprev), .combine = c, .packages = c("hdm", "dplyr", "irlba")) %dopar% {
      train_start <- i
      train_end <- length(y_h[valid_idx]) - nprev + i - 1
      
      Z_train_raw <- Z[train_start:train_end, ]
      y_train <- y_h[train_start:train_end]
      Z_test_raw <- Z[train_end + 1, , drop = FALSE]
      
      X_train_raw <- X_aligned[train_start:train_end, ]
      X_test_raw <- X_aligned[train_end + 1, , drop = FALSE]
      
      # === Compute PCA factors from X_t and append to Z ===
      pcs_data <- add_pca_factors(X_train_raw, X_test_raw, n_pcs = n_pcs, n_lags = n_lags)
      Z_train <- cbind(Z_train_raw, pcs_data$train_pcs)
      Z_test <- cbind(Z_test_raw, pcs_data$test_pcs)
      
      model <- rlasso(Z_train, y_train, post = TRUE)
      predict(model, newdata = Z_test)
    }
    
    real <- tail(y_h[valid_idx], nprev)
    rmse <- sqrt(mean((real - preds)^2))
    mae <- mean(abs(real - preds))
    
    results[[z_name]][[hname]] <- list(pred = preds, rmse = rmse, mae = mae)
    cat("    Horizon", h, "done. RMSE:", rmse, "MAE:", mae, "\n")
    saveRDS(results, save_path)
  }
  
  cat("*** Finished all horizons for", z_name, "***\n")
}

stopCluster(cl)


```


```{r lasso bic no factors}
alpha <- 1
IC <- "bic"
save_path <- "lasso_bic_results_100_icglm.rds"

# Load previous progress if available
if (file.exists(save_path)) {
  results <- readRDS(save_path)
  cat("Loaded existing results from", save_path, "\n")
} else {
  results <- list()
  cat("Starting new results list\n")
}


# ---- parallel setup ----
Z_list <- all_Z_list[
  order(sapply(all_Z_list, ncol))
]
Z_list <- Z_list[!grepl("F", names(Z_list))]

Z_list <- lapply(Z_list, function(df) {
  df %>% drop_na()
})

results <- list()

for (z_name in names(Z_list)) {
  
  Z_full <- Z_list[[z_name]]
  Z <- Z_full %>% select(-sasdate)
  y_vec <- tail(y_t$CPI_t, nrow(Z))
  
  cat("\n=============================\nRunning:", z_name, "\n")
  
  results[[z_name]] <- list()
  
  for (h in horizons) {
    
    cat("  Horizon:", h, "\n")
    
    y_target <- dplyr::lead(y_vec, h)[1:(nrow(Z) - h)]
    Z_trim   <- Z[1:(nrow(Z) - h), ]
    
    window_size <- nrow(Z_trim) - nprev
    
    # parallel version of rolling window
    pred_out <- foreach(i = seq_len(nprev), .combine = "c", .packages = c("hdm", "HDeconometrics")) %dopar% {
      
      train_start <- i
      train_end   <- i + window_size - 1
      
      Z_train <- as.matrix(Z_trim[train_start:train_end, ])
      y_train <- y_target[train_start:train_end]
      Z_test  <- as.matrix(Z_trim[train_end + 1, ])
      
      if (sd(y_train) == 0 || all(is.na(y_train))) {
        return(NA)
      }
      
      model <- ic.glmnet(
        x = Z_train,
        y = y_train,
        alpha = alpha,
        crit = IC
      )
      
      as.numeric(predict(model, Z_test))
    }
    
    true_y <- tail(y_target, nprev)
    
    results[[z_name]][[paste0("h", h)]] <- list(
      pred = pred_out,
      rmse = sqrt(mean((true_y - pred_out)^2, na.rm = TRUE)),
      mae  = mean(abs(true_y - pred_out), na.rm = TRUE)
    )
    
    cat("    Horizon", h, "done.\n")
    cat("    MSE:", round(results[[z_name]][[paste0("h", h)]]$rmse, 4),
        "| MAE:", round(results[[z_name]][[paste0("h", h)]]$mae, 4), "\n")
    saveRDS(results, save_path)
    cat("  Progress saved to", save_path, "\n")
  }
}

stopCluster(cl)  

# print summary
cat("\n=========== SUMMARY (LASSO via IC) ===========\n")
for (z_name in names(results)) {
  cat("Results for:", z_name, "\n")
  for (h in horizons) {
    err <- results[[z_name]][[paste0("h", h)]]
    cat("  h =", h,
        "| RMSE =", round(err$rmse, 4),
        "| MAE =", round(err$mae, 4), "\n")
  }
}

```


```{r lasso bic WITH factors}
alpha <- 1
IC <- "bic"
n_pcs <- 32
n_lags <- 4
save_path <- "lasso_bic_results_100_icglm.rds"

# --- Load previous progress if available ---
if (file.exists(save_path)) {
  results <- readRDS(save_path)
  cat("Loaded existing results from", save_path, "\n")
} else {
  results <- list()
  cat("Starting new results list\n")
}

# --- Load data ---
Z_list <- all_Z_list[
  order(sapply(all_Z_list, ncol))
]
Z_list <- Z_list[grepl("F", names(Z_list))]
Z_list <- Z_list[!grepl("MAF", names(Z_list))]

# Predefined stationary X_t for PCA
X_t <- X_t

# Drop any remaining NAs (alr checked that they are due to lagging)
Z_list <- lapply(Z_list, function(df) {
  df %>% drop_na()
})


# --- Main Loop ---
for (z_name in names(Z_list)) {
  Z_full <- Z_list[[z_name]]
  Z <- Z_full %>% select(-sasdate)
  y_vec <- tail(y_t$CPI_t, nrow(Z))  # align y
  cat("\n=============================\nRunning:", z_name, "\n")
  results[[z_name]] <- list()
  
  for (h in horizons) {
    hname <- paste0("h", h)
    cat("  Horizon:", h, "\n")
    
    # Lead actuals by horizon
    y_target <- dplyr::lead(y_vec, h)[1:(nrow(Z) - h)]
    Z_trim   <- Z[1:(nrow(Z) - h), , drop = FALSE]
    
    # Rolling window: exactly nprev predictions
    pred_out <- foreach(i = seq_len(nprev), .combine = "c", .packages = c("hdm", "HDeconometrics")) %dopar% {
      train_start <- i
      train_end   <- length(y_target) - nprev + i - 1
      
      Z_train <- as.matrix(Z_trim[train_start:train_end, ])
      y_train <- y_target[train_start:train_end]
      Z_test  <- as.matrix(Z_trim[train_end + 1, ])
      
      if (sd(y_train) == 0 || all(is.na(y_train))) return(NA)
      
      model <- ic.glmnet(x = Z_train, y = y_train, alpha = alpha, crit = IC)
      as.numeric(predict(model, Z_test)) 
    }
    
    # Compute RMSE/MAE
    true_y <- tail(y_target, nprev)
    rmse <- sqrt(mean((true_y - pred_out)^2, na.rm = TRUE))
    mae  <- mean(abs(true_y - pred_out), na.rm = TRUE)
    
    results[[z_name]][[hname]] <- list(
      pred = pred_out,
      rmse = rmse,
      mae = mae
    )
    
    cat("    Horizon", h, "done. RMSE:", round(rmse, 4), "MAE:", round(mae, 4), "\n")
    saveRDS(results, save_path)
  }
}

stopCluster(cl)

# --- Print Summary ---
cat("\n=========== SUMMARY (ic.glmnet + PCA) ===========\n")
for (z_name in names(results)) {
  cat("Results for:", z_name, "\n")
  for (h in horizons) {
    err <- results[[z_name]][[paste0("h", h)]]
    cat("  h =", h,
        "| RMSE =", round(err$rmse, 4),
        "| MAE =", round(err$mae, 4), "\n")
  }
}
```


```{r table of results}

#read results
res_plugin_lasso <- readRDS("rlasso_results.rds")
res_bic_lasso    <- readRDS("lasso_bic_results_100_icglm.rds")

# comparison table
results_to_df <- function(res_list, method_name) {
  df <- lapply(names(res_list), function(z_name) {
    lapply(names(res_list[[z_name]]), function(h) {
      tibble(
        Z = z_name,
        Horizon = h,
        RMSE = res_list[[z_name]][[h]]$rmse,
        MAE  = res_list[[z_name]][[h]]$mae
      )
    }) |> bind_rows()
  }) |> bind_rows()
  df$Method <- method_name
  df
}

df_plugin <- results_to_df(res_plugin_lasso, "Plug-in Lasso")
df_bic    <- results_to_df(res_bic_lasso, "BIC Lasso")

comparison_df <- bind_rows(df_plugin, df_bic) %>%
  pivot_wider(names_from = Method, values_from = c(RMSE, MAE))

print(comparison_df)
```


```{r plot forecasts vs actual}
# plot forecasts against actual per method, each Z a different colour
plot_forecasts <- function(res_list, y_df, method_name) {
  y_vec <- y_df$CPI_t
  dates <- y_df$sasdate
  
  df <- lapply(names(res_list), function(z_name) {
    lapply(names(res_list[[z_name]]), function(h) {
      h_num <- as.numeric(gsub("h", "", h))
      n <- length(res_list[[z_name]][[h]]$pred)
      
      tibble(
        Date = tail(dplyr::lead(dates, h_num), n),
        Forecast = res_list[[z_name]][[h]]$pred,
        Actual   = tail(dplyr::lead(y_vec, h_num), n),
        Z = z_name,
        Horizon = paste0("h", h_num)
      )
    }) |> bind_rows()
  }) |> bind_rows()
  
  ggplot(df, aes(x = Date)) +
    geom_line(aes(y = Actual), color = "black", alpha = 0.5) +
    geom_line(aes(y = Forecast, color = Z)) +
    scale_x_date(date_labels = "%Y", date_breaks = "1 year") +
    facet_wrap(~ Horizon, scales = "free_y") +
    labs(title = paste("Forecast vs Actual —", method_name),
         y = "Value", x = "Year") +
    theme_minimal() +
    theme(legend.position = "bottom",
          axis.text.x = element_text(angle = 45, hjust = 1))
}


# Example usage
plot_forecasts(res_plugin_lasso, y_t, "Plug-in Lasso")
plot_forecasts(res_bic_lasso, y_t, "BIC Lasso")


```

```{r plot of rmses}

plot_rmses <- function(res_list, method_name) {
  df <- lapply(names(res_list), function(z_name) {
    lapply(names(res_list[[z_name]]), function(h) {
      tibble(
        Z = z_name,
        Horizon = h,
        RMSE = res_list[[z_name]][[h]]$rmse
      )
    }) |> bind_rows()
  }) |> bind_rows()
  
  ggplot(df, aes(x = Horizon, y = RMSE, color = Z, group = Z)) +
    geom_line() +
    geom_point() +
    labs(title = paste("RMSE across horizons —", method_name),
         x = "Horizon", y = "RMSE") +
    theme_minimal()
}

plot_rmses(res_plugin_lasso, "Plug-in Lasso")
plot_rmses(res_bic_lasso, "BIC Lasso")

```
```{r lasso bests}
get_best_models <- function(res_list) {
  horizons <- names(res_list[[1]])  # assume all have same horizons
  
  best_list <- lapply(horizons, function(h) {
    # get all rmse values for this horizon across Zs
    all_rmse <- sapply(res_list, function(z) z[[h]]$rmse)
    best_z <- names(which.min(all_rmse))
    best_model <- res_list[[best_z]][[h]]
    
    list(
      Z = best_z,
      pred = best_model$pred,
      rmse = best_model$rmse,
      mae = best_model$mae
    )
  })
  
  names(best_list) <- horizons
  return(best_list)
}

# Example usage:
lasso_plugin_best <- get_best_models(res_plugin_lasso)
lasso_bic_best <- get_best_models(res_bic_lasso)
```

