---
title: "lasso"
author: "Abigail"
date: "2025-10-28"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r load libraries}
library(glmnet)
library(hdm)
library(tidyverse)
```

```{r helper functions}

RMSE <- function(pred, truth){ 
  return(sqrt(mean((truth - pred)^2)))
}

MSE <- function(pred, truth){ 
  return(mean((truth - pred)^2)) 
}

# #scale a df using min-max from training data
# minmax_scale <- function(df) {
#   mins <- apply(df, 2, min, na.rm = TRUE)
#   maxs <- apply(df, 2, max, na.rm = TRUE)
#   
#   scaled <- sweep(df, 2, mins, "-")
#   scaled <- sweep(scaled, 2, maxs - mins, "/")
#   
#   list(scaled = scaled, mins = mins, maxs = maxs)
# }
# 
# # APPLY previously fitted min-max parameters to a new dataset
# minmax_apply <- function(df, mins, maxs) {
#   scaled <- sweep(df, 2, mins, "-")
#   scaled <- sweep(scaled, 2, maxs - mins, "/")
#   return(scaled)
# }
# 
# #Inverse transform (to get back actual values)
# minmax_unscale <- function(scaled, mins, maxs) {
#   unscaled <- sweep(scaled, 2, maxs - mins, "*")
#   unscaled <- sweep(unscaled, 2, mins, "+")
#   return(unscaled)
# }
  
```


## Split Training and Validation Set, Test Set

```{r set}
# minmax scaling on all predictors and Y
#scaled_part <- minmax_scale(Z_8[, !(names(Z_8) %in% c("sasdate"))])
#df_scaled <- cbind(sasdate = Z_8$sasdate, scaled_part$scaled)

#subsetting training and validation set
df_train <- Z_8 %>%
  mutate(sasdate = as.Date(sasdate, format = "%m/%d/%Y")) %>%
  filter(year(sasdate) < 2020)
df_test <- Z_8 %>%
  mutate(sasdate = as.Date(sasdate, format = "%m/%d/%Y")) %>%
  filter(year(sasdate)> 2019)

df_train_nodate = df_train %>%
  select(-sasdate)
df_test_nodate = df_test %>%
  select(-sasdate)

#x and y var
Y_train <- df_train[,"CPIAUCSL"]
Y_test <- df_test[,"CPIAUCSL"]
X_train <- df_train %>% select(-c(sasdate, CPIAUCSL))
X_test <- df_test %>% select(-c(sasdate, CPIAUCSL))

#validation set
nprev=60 #number of out-of-sample observations (test window )
Y_validation = tail(Y_train,nprev) 
X_validation = tail(X_train,nprev)

# actual training set - validation
Y_train_smaller = Y_train[1:(length(Y_train) - 60)]
X_train_smaller = X_train[1:(length(X_train) - 60)]
```


## LASSO

```{r plug in lambda}
# define horizons of interest
horizons <- c(1,3,6,9,12)

# store results
rmse_vec <- numeric(length(horizons))
mse_vec <- numeric(length(horizons))
names(rmse_vec) <- paste0("h", horizons)
names(mse_vec) <- paste0("h", horizons)
pred_list <- list()

for(i in seq_along(horizons)){
  h <- horizons[i]
  
  # shifted target for training (x1t,x2t...-> y(t+h))
  Y_train_h <- dplyr::lead(Y_train, h)
  valid_idx <- !is.na(Y_train_h)
  X_train_h <- as.matrix(X_train[valid_idx, ])
  Y_train_h <- Y_train_h[valid_idx]
  
  # fit rlasso
  fit <- rlasso(X_train_h, Y_train_h, post=FALSE)
  
  # shifted target for test
  Y_test_h <- dplyr::lead(Y_test, h) %>% na.omit()
  X_test_h <- as.matrix(X_test[1:length(Y_test_h), ])
  
  # predict
  yhat <- predict(fit, newdata = X_test_h)
  pred_list[[i]] <- yhat
  
  # compute MSE and RMSE
  mse <- MSE(yhat, Y_test_h)
  mse_vec[i] <- mse
  rmse_vec[i] <- sqrt(mse)
}

mse_vec
rmse_vec
```

```{r plug in lambda, post-lasso}

# store results
rmse_vec2 <- numeric(length(horizons))
mse_vec2 <- numeric(length(horizons))
names(rmse_vec2) <- paste0("h", horizons)
names(mse_vec2) <- paste0("h", horizons)
pred_list2 <- list()

for(i in seq_along(horizons)){
  h <- horizons[i]
  
  # shifted target for training (x1t,x2t...-> y(t+h))
  Y_train_h <- dplyr::lead(Y_train, h)
  valid_idx <- !is.na(Y_train_h)
  X_train_h <- as.matrix(X_train[valid_idx, ])
  Y_train_h <- Y_train_h[valid_idx]
  
  # fit rlasso
  fit <- rlasso(X_train_h, Y_train_h, post=TRUE)
  
  # shifted target for test
  Y_test_h <- dplyr::lead(Y_test, h) %>% na.omit()
  X_test_h <- as.matrix(X_test[1:length(Y_test_h), ])
  
  # predict
  yhat <- predict(fit, newdata = X_test_h)
  pred_list2[[i]] <- yhat
  
  # compute MSE and RMSE
  mse <- MSE(yhat, Y_test_h)
  mse_vec2[i] <- mse
  rmse_vec2[i] <- sqrt(mse)
}

mse_vec2
rmse_vec2
```


```{r lasso with bic}
rmse_vec3 <- numeric(length(horizons))
mse_vec3 <- numeric(length(horizons))

# setting user-defined grid
# grid = 10^seq(10, -2, length = 100)

# function to choose lambda via BIC 
choose_lambda_bic <- function(X, Y, lambda_grid) {
  n <- nrow(X)
  fit <- glmnet(as.matrix(X), as.numeric(Y), alpha = 1, lambda = lambda_grid, standardize = FALSE)
  
  yhat <- predict(fit, as.matrix(X)) # predicted values
  
  # compute bic
  rss <- colSums((yhat - as.numeric(Y))^2)
  df <- fit$df
  bic <- n * log(rss / n) + df * log(n)
  
  # choose best lambda
  plot(bic~lambda_grid)
  best_lambda <- lambda_grid[which.min(bic)]
  return(best_lambda)
}

# find best lambda for all horizons FIND GOOD GRID PLSSSSS
lambda_grid <- 10^seq(-4, 0.5, length.out = 100)

best_lambdas <- c()

for (h in horizons) {
  Y_train_h <- Y_train[(1 + h):length(Y_train)]
  X_train_h <- X_train[1:(nrow(X_train) - h), ]
  
  best_lambda <- choose_lambda_bic(X_train_h, Y_train_h, lambda_grid)
  best_lambdas <- c(best_lambdas, best_lambda)
  
  cat("h =", h, ": best lambda (BIC) =", round(best_lambda, 6), "\n")
  
  # fit models with best lambda
  fit <- glmnet(as.matrix(X_train_h), as.numeric(Y_train_h),
                alpha = 1, lambda = best_lambda, standardize = FALSE)
  
  # predict on test set
  # align test X with horizon h if needed
  Y_test_h <- Y_test[(1 + h):length(Y_test)] #only start h steps after the first ytest obs
  X_test_h <- X_test[1:(nrow(X_test) - h), ] #dont use the last h X obs
  yhat <- predict(fit, as.matrix(X_test_h))

  rmse <- RMSE(yhat, Y_test_h)
  mse  <- MSE(yhat, Y_test_h)
  mse_vec3[i] <- mse
  rmse_vec3[i] <- rmse
}

mse_vec3
rmse_vec3

```

```{r lasso with rolling window}
horizons <- c(1,3,6,12)
save_path <- "rlasso_results.rds"

# Load previous progress if available
if (file.exists(save_path)) {
  results <- readRDS(save_path)
  cat("Loaded existing results from", save_path, "\n")
} else {
  results <- list()
  cat("Starting new results list\n")
}

runrlasso_Z <- function(Z, y, pl = FALSE) {
  df <- as.data.frame(Z)
  model <- rlasso(df, y, post = pl)
  pred <- predict(model, newdata = tail(df, 1))
  return(list(model = model, pred = pred))
}

rlasso.rolling.window.Z <- function(Z, y, nprev, pl = FALSE) {
  if (length(y) > nrow(Z)) {
    y <- tail(y, nrow(Z))
  } else if (length(y) < nrow(Z)) {
    Z <- Z[(nrow(Z) - length(y) + 1):nrow(Z), , drop = FALSE]
  }
  
  n <- length(y)
  save.pred <- rep(NA, nprev)
  
  for (i in seq_len(nprev)) {
    print(i)
    train_start <- i
    train_end <- n - nprev + i - 1
    
    Z_train <- Z[train_start:train_end, ]
    y_train <- y[train_start:train_end]
    Z_test <- Z[train_end + 1, , drop = FALSE]
    
    model <- rlasso(Z_train, y_train, post = pl)
    save.pred[i] <- predict(model, newdata = Z_test)
  }
  
  real <- tail(y, nprev)
  rmse <- sqrt(mean((real - save.pred)^2))
  mae <- mean(abs(real - save.pred))
  
  return(list(pred = save.pred, errors = c(rmse = rmse, mae = mae)))
}

# === MAIN LOOP ===
all_Z_list <- readRDS("all_Z_matrices.rds")
Z_list <- all_Z_list
#Z_list = all_Z_list["Z_X"]
y_t = y_t 
nprev <- 66

for (z_name in names(Z_list)) {
  Z_full <- Z_list[[z_name]]
  Z <- Z_full %>% select(-sasdate)
  cat("\n=============================\n")
  cat("Running for:", z_name, "\n")
  
  if (is.null(results[[z_name]])) results[[z_name]] <- list()
  
  # Tail y to match Z
  if (nrow(y_t) > nrow(Z)) {
    y_aligned <- tail(y_t, nrow(Z))
    cat("  Tailed y from", nrow(y_t), "to", nrow(y_aligned), "\n")
  } else {
    y_aligned <- y_t
  }

  # Print first 3 dates for diagnostics
  cat("  First 3 Z dates:", paste(as.character(Z_full$sasdate[1:3]), collapse = ", "), "\n")
  cat("  First 3 y dates:", paste(as.character(y_aligned$sasdate[1:3]), collapse = ", "), "\n")
  
  for (h in horizons) {
    if (!is.null(results[[z_name]][[paste0("h", h)]])) {
      cat("  Skipping horizon", h, "(already done)\n")
      next
    }
    
    cat("  Horizon:", h, "\n")
    y_h <- dplyr::lead(y_aligned$CPI_t, h)  # numeric target for rolling window
    valid_idx <- 1:(length(y_h) - h)
    
    out <- tryCatch(
      rlasso.rolling.window.Z(Z[valid_idx, ], y_h[valid_idx], nprev = nprev, pl = FALSE),
      error = function(e) {
        cat("  Error at", z_name, "h=", h, ":", conditionMessage(e), "\n")
        return(NULL)
      }
    )
    
    results[[z_name]][[paste0("h", h)]] <- out
    cat("    Horizon", h, "done.\n")
    
    # Save progress after each horizon
    saveRDS(results, save_path)
    cat("  Progress saved to", save_path, "\n")
  }

  cat("*** Finished all horizons for", z_name, "***\n\n")
}


# === Summary printout ===
cat("\nSummary of results:\n")
for (z_name in names(results)) {
  cat("Results for:", z_name, "\n")
  for (h in horizons) {
    if (!is.null(results[[z_name]][[paste0("h", h)]])) {
      error_vec <- results[[z_name]][[paste0("h", h)]]$errors
      cat("  Horizon", h, ": RMSE =", round(error_vec["rmse"], 4), 
          ", MAE =", round(error_vec["mae"], 4), "\n")
    } else {
      cat("  Horizon", h, ": not yet computed\n")
    }
  }
}

```


