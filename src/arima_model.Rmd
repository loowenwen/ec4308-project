---
title: "arima"
author: "Melanie Gan"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load required libraries + helper functions
```{r}
library(dplyr)
library(forecast)


RMSE_fn <- function(pred, truth){ 
  return(sqrt(mean((truth - pred)^2, na.rm = TRUE)))
}
```

Load in dataset
```{r}
train <- read.csv("../data/fred_train.csv")
test <- read.csv("../data/fred_test.csv")

y_train <- read.csv("../data/y_train.csv")
y_train <- read.csv("../data/y_train.csv")
```


# ARIMA MODELS 

## Model: all X's 
### Rolling Window forecast functions
```{r}
nprev = nrow(test)          #test window

all_X <- rbind(train, test)
all_X <- all_X %>% select(-sasdate)

all_Y <- rbind(y_train, y_test)

### Function to run auto.arima on each training window
runarima <- function(Y, X, lag) {
  y <- Y$CPI_t          #extract y variable (CPI)
  X <- as.matrix(X)
  
  #auto.arima() finds best model
  #model <- Arima(y, order = c(best$p, 0, best$q), xreg = X)
  model <- auto.arima(y, xreg = X)
  
  X_out <- matrix(rep(X[nrow(X), ], lag), nrow = lag, byrow = TRUE)
  colnames(X_out) <- colnames(X)   
  
  fc <- forecast(model, h = lag, xreg = X_out)
  
  return(list("model" = model, "pred" = fc$mean[lag]))
}

### Function to run the rolling window forecast
arima.rolling.window <- function(Y, X, nprev, lag = 1) {
  save.pred <- matrix(NA, nprev, 1)
  n <- nrow(Y)
  for (i in 1:nprev) {
    # Define rolling window
    end_idx <- n - nprev + i - lag
    start_idx <- end_idx - ((n - nprev) - 1)  # fixed-size rolling window
    
    if (start_idx < 1 || end_idx < 1) next
    Y.window <- Y[start_idx:end_idx, ]
    X.window <- X[start_idx:end_idx, , drop = FALSE]
    if (nrow(Y.window) < 10) next
    
    # Fit ARIMA and make h-step forecast
    arima_res <- runarima(Y.window, X.window, lag)
    # Forecast corresponds to time t = end_idx + lag
    forecast_pos <- end_idx + lag
    if (forecast_pos <= n) {
      save.pred[i,] <- arima_res$pred
    }
    cat("iteration", i, "trained:", start_idx, "-", end_idx, 
        "| forecast:", forecast_pos, "\n")
  }
  real <- Y$CPI_t
  #cat("Number of non-NA predictions:", sum(!is.na(save.pred)), "\n")
  #print(save.pred)
  #print(tail(real, nprev))
  rmse <- sqrt(mean((tail(real, nprev) - save.pred)^2, na.rm = TRUE))
  mae  <- mean(abs(tail(real, nprev) - save.pred), na.rm = TRUE)
  
  errors <- c(rmse = rmse, mae = mae)
  return(list(pred = save.pred, errors = errors))
}
```

### Forecast
```{r}
# Run forecasts
# Side Note: this takes quite long to run due to auto.arima
arima1c=arima.rolling.window(all_Y, all_X, nprev,1)
arima3c=arima.rolling.window(all_Y, all_X, nprev,3)
arima6c=arima.rolling.window(all_Y, all_X, nprev,6)
arima12c=arima.rolling.window(all_Y, all_X, nprev,12)


#RMSE's
arima.rmse1 = arima1c$errors[1]
arima.rmse3 = arima3c$errors[1]
arima.rmse6 = arima6c$errors[1]
arima.rmse12 = arima12c$errors[1]
```








## Model 2: First 25 PCs + Chosen X's
### PCA
```{r}
#Normalize the data
data_normalized <- data.frame( scale(data[, 2:127]))

# Splitting into train-validation-test sets
train_normalized <- data_normalized[1:180, ]
validation_normalized <- data_normalized[181:240, ]
test_normalized <- tail(data_normalized, 12)

# Do PCA
train_no_y_normal <- train_normalized %>% select(-CPIAUCSL) %>%         #remove Y variable 
  mutate(across(everything(), as.numeric))

data_pca <- prcomp(train_no_y_normal)
summary(data_pca)    

#Scree Plot
plot(data_pca, type = "l", main = "Scree Plot of PCA Factors", npcs = 125)

#Retain the first 25 PCs, it explains ~85% of the variance
train_pca_25 <- data_pca$x[, 1:25]
```

### Model



